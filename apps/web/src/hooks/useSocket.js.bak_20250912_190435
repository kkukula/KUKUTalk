import { useEffect, useMemo, useRef, useState } from 'react'
import io from 'socket.io-client'
import { encryptMessage, decryptMessage, isE2EText } from '../lib/e2e'

export function useSocket(user, e2e){
  const [connected, setConnected] = useState(false)
  const [messages, setMessages] = useState([])
  const [system, setSystem] = useState(null)
  const socketRef = useRef(null)

  const base = useMemo(()=> (import.meta.env.VITE_API_URL || 'http://localhost:3001'), [])
  const auth = useMemo(()=> (user && user.token) ? { token: user.token } : {}, [user])

  useEffect(()=>{
    const s = io(base, { auth })
    socketRef.current = s
    s.on('connect', ()=> setConnected(true))
    s.on('disconnect', ()=> setConnected(false))
    s.on('system:block', (p)=> setSystem({ type:'block', payload:p }))
    s.on('system:ack', ()=> setSystem(null))
    s.on('chat:message', async (m)=>{
      try {
        let txt = m.text
        if (isE2EText(txt) && e2e && e2e.enabled && e2e.pass){
          const dec = await decryptMessage(txt, e2e.pass, m.room || '')
          txt = dec || '[locked]'
        }
        setMessages(prev => prev.concat([{ from: m.from, text: txt, ts: m.ts, room: m.room || null }]))
      } catch(e) {}
    })
    return ()=>{ try { s.close() } catch(e){} }
  }, [base, auth, e2e && e2e.enabled, e2e && e2e.pass])

  async function sendMessage(text, room){
    const s = socketRef.current; if (!s) return
    const from = (user && user.name) || 'DemoUser'
    const ts = Date.now()
    const plain = String(text || '')
    setMessages(prev => prev.concat([{ from, text: plain, ts, room: room || null }]))
    let payload = { from, text: plain, ts }
    if (room) payload.room = room
    if (e2e && e2e.enabled && e2e.pass){
      try { payload.text = await encryptMessage(plain, e2e.pass, room || '') } catch(e){}
    }
    s.emit('chat:message', payload)
  }

  return { connected, sendMessage, messages, system }
}
