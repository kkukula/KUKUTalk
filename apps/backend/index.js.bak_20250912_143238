require('dotenv').config()
const express = require('express')
const cors = require('cors')
const http = require('http')
const helmet = require('helmet')
const rateLimit = require('express-rate-limit')
const compression = require('compression')
const hpp = require('hpp')
const jwt = require('jsonwebtoken')
const { readJson } = require('./lib/store')
const { requireAuth, requireRole } = require('./middleware/authz')
const { registerParent, login, me } = require('./routes/auth')
const { createChild, listChildren, addWhitelist } = require('./routes/profiles')
const { setSchedule, getSchedule, requestContact, listRequests, approveRequest } = require('./routes/controls')

const app = express()
const PORT = Number(process.env.PORT || 3001)
const ORIGIN = process.env.CORS_ORIGIN || 'http://localhost:5173'
const ALLOWLIST = (process.env.CORS_ALLOWLIST || ORIGIN).split(',').map(s => s.trim()).filter(Boolean)
const BODY_LIMIT = process.env.BODY_LIMIT || '64kb'
const RATE_WINDOW = Number(process.env.RATE_LIMIT_WINDOW_MS || 60000)
const RATE_MAX = Number(process.env.RATE_LIMIT_MAX || 60)
const MSG_MAX_LEN = Number(process.env.MSG_MAX_LEN || 500)
const MSG_MIN_INTERVAL = Number(process.env.MSG_MIN_INTERVAL_MS || 750)
const ENABLE_CONTROLS = String(process.env.PARENTAL_CONTROLS_ENABLED||'true').toLowerCase() === 'true'
const cspConnect = (process.env.CSP_CONNECT || 'http://localhost:5173 ws://localhost:3001').split(/\s+/)

function corsOrigin(origin, cb) {
  if (!origin) return cb(null, true)
  if (ALLOWLIST.indexOf(origin) !== -1) return cb(null, true)
  return cb(new Error('CORS not allowed'), false)
}

app.set('x-powered-by', false)
app.use(hpp())
app.use(compression())
app.use(express.json({ limit: BODY_LIMIT }))
app.use(express.text({ limit: BODY_LIMIT, type: 'text/*' }))
app.use(helmet({
  contentSecurityPolicy: {
    useDefaults: true,
    directives: {
      defaultSrc: [(process.env.CSP_DEFAULT || '\'self\'')],
      connectSrc: [(process.env.CSP_DEFAULT || '\'self\'')].concat(cspConnect),
      scriptSrc: [(process.env.CSP_DEFAULT || '\'self\'')],
      imgSrc: [(process.env.CSP_DEFAULT || '\'self\'')].concat(['data:']),
      styleSrc: [(process.env.CSP_DEFAULT || '\'self\'')].concat(['unsafe-inline'])
    }
  },
  crossOriginEmbedderPolicy: false
}))
app.use(cors({ origin: corsOrigin, credentials: false }))
const limiter = rateLimit({ windowMs: RATE_WINDOW, max: RATE_MAX, standardHeaders: true, legacyHeaders: false })
app.use(limiter)

app.get('/health', (_req, res) => res.json({ ok: true, ts: Date.now() }))

// Auth
app.post('/auth/register-parent', registerParent)
app.post('/auth/login', login)
app.get('/me', requireAuth, me)

// Profiles and parental controls
app.post('/profiles/child', requireAuth, requireRole('parent'), createChild)
app.get('/profiles/child', requireAuth, requireRole('parent'), listChildren)
app.post('/contacts/whitelist', requireAuth, requireRole('parent'), addWhitelist)

app.post('/controls/schedule', requireAuth, requireRole('parent'), setSchedule)
app.get('/controls/schedule', requireAuth, requireRole('parent'), getSchedule)
app.post('/contacts/request', requireAuth, requireRole('child'), requestContact)
app.get('/contacts/requests', requireAuth, requireRole('parent'), listRequests)
app.post('/contacts/approve', requireAuth, requireRole('parent'), approveRequest)

// Socket.IO
const server = http.createServer(app)
const io = require('socket.io')(server, { cors: { origin: corsOrigin, methods: ['GET','POST'] } })

io.use((socket, next) => {
  try {
    const token = (socket.handshake.auth && socket.handshake.auth.token) || null
    if (!token) return next()
    const payload = jwt.verify(token, process.env.JWT_SECRET || 'dev')
    socket.user = payload
    return next()
  } catch (e) {
    // no auth -> proceed but will restrict actions
    return next()
  }
})

io.on('connection', (socket) => {
  socket.data.lastMsg = 0
  socket.on('chat:message', (msg) => {
    const now = Date.now()
    if (now - (socket.data.lastMsg || 0) < MSG_MIN_INTERVAL) {
      socket.emit('system:block', { reason:'rate_limited' })
      return
    }
    socket.data.lastMsg = now

    const safe = sanitizeMessage(msg)
    if (!safe) { socket.emit('system:block', { reason:'invalid' }); return }

    if (ENABLE_CONTROLS) {
      const verdict = enforceControls(socket.user, safe)
      if (!verdict.ok) {
        socket.emit('system:block', { reason: verdict.reason })
        return
      }
    }

    // ok -> echo ack to sender and broadcast to others in room or globally
    socket.emit('system:ack', { ok:true })
    if (safe.room) {
      socket.to(safe.room).emit('chat:message', safe)
      socket.join(safe.room) // ensure sender joins its room
    } else {
      socket.broadcast.emit('chat:message', safe)
    }
  })
})

function sanitizeMessage(input) {
  try {
    const obj = Object(input) === input ? input : {}
    const from = String(obj.from || '').slice(0, 50)
    const text = String(obj.text || '').replace(/\u0000/g, '').slice(0, MSG_MAX_LEN)
    const ts = Number(obj.ts || Date.now())
    const room = obj.room ? String(obj.room).slice(0, 100) : null
    if (!from || !text) return null
    return { from, text, ts, room }
  } catch (e) { return null }
}

function enforceControls(user, msg) {
  // If no JWT user, restrict to broadcast read-only
  if (!user) return { ok:false, reason:'auth_required' }
  const roles = (user.roles||[])
  if (roles.indexOf('child') === -1) return { ok:true }
  // child path
  if (!msg.room) return { ok:false, reason:'room_required' }
  const db = readJson()
  const child = db.children.find(c=>c.id===user.sub)
  if (!child) return { ok:false, reason:'child_unknown' }
  const parent = db.users.find(u=>u.children && u.children.indexOf(child.id)!==-1)
  if (!parent) return { ok:false, reason:'parent_unknown' }

  // whitelist check
  const wl = parent.whitelist || []
  if (wl.indexOf(msg.room) === -1) return { ok:false, reason:'not_whitelisted' }

  // schedule check
  const schedules = (((db.controls||{}).schedules||{})[child.id]) || []
  if (!isWithinSchedule(schedules, new Date())) return { ok:false, reason:'outside_schedule' }

  return { ok:true }
}

function isWithinSchedule(rules, now) {
  if (!Array.isArray(rules) || !rules.length) return false
  const dow = now.getDay()
  const hh = now.getHours(); const mm = now.getMinutes()
  const cur = hh*60+mm
  for (const r of rules) {
    const start = toMinutes(r.start); const end = toMinutes(r.end)
    if (r.days && r.days.indexOf(dow)!==-1) {
      if (start <= end) { if (cur>=start && cur<=end) return true }
      else { if (cur>=start || cur<=end) return true } // overnight window
    }
  }
  return false
}
function toMinutes(hhmm){
  try{ const p = String(hhmm).split(':'); return Number(p[0])*60+Number(p[1]) }catch(e){ return 0 }
}

server.listen(PORT, () => { console.log('KUKUTalk backend listening on http://localhost:' + PORT) })
